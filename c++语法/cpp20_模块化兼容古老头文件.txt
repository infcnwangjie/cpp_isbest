模块化支持
模块支持被写入新的语言核心，这一新的封装方式甚至可以认为是C++诞生35年以来最大的一个新功能； 也是语言标准化以来，第一次通过修改核心语法允许程序员用一种全新的方式来描述带命名的信息封装边界。

信息封装手法的更新
传统的封装手段基本上都是采用如下的方式：

将用户自定义的结构或者类取一个名字
将相关联的细节都隐藏在这个名字的后面
不管是变量声明，函数定义，自定义的类，结构体，无一例外都满足这个模式。即使是模板元编程方法，其实也是通过类型绑定的方法间接地使用上述的封装手段。

头文件的不完美封装
除了上述的基本信息封装单元，C++中屈指可数的封装办法就剩下了从古老的C语言继承下来的头文件包含的方式了。 在软件规模还局限在数万行代码一下的时代，使用头文件的方式一股脑将需要的东西都大包大揽在一个编译单元中，然后使用诸如唯一定义规则的方法让链接器在生成最终可执行代码或者库的时候做冲突检测是一个简单而优雅的方案。 因为对于它想解决的问题规模来说，这样的解决方案就足够了。

然而随着行业中软件项目的复杂性与日俱增，越来越多的商业项目需要数百甚至上千的头文件被包含在一个编译单元中，这个时候既有的方式就越来越捉襟见肘

编译时间长成为了一个突出的痛点，以至于实际项目中出于减少编译时间的考虑，聪明的工程师发明了如IWYU的头文件检测工具来缓解这一问题
像pimp惯用法这样的技术手段可以减少放在头文件中的依赖，但是程序员却不得不承担额外内存申请的开销（可能没有这么个指针很多对象本身就可以在栈上完成快速构造和析构），即使有了unique_ptr来环境内存泄露的隐忧
模板方式提供的抽象代码无法声明，必须放置在头文件中内联实现，否则对应的cpp文件在编译单元进行代码生成的时候会因为找不到定义而无法通过编译；之前提出的一些export声明也因为种种缺陷和编译器支持不力而被废弃
简单来看，现代的编程语言都或多或少带有模块化系统；缺乏现代的模块化支持成为了C++语言的一种硬伤，严重制约了C++开发大项目的能力。

模块化系统需要的核心功能
模块化是一个很自然的逻辑信息隐藏手段，一个良好的模块化系统应该允许

良好的信息隔离，可以方便的指定哪些可以被外部访问，哪些应该不允许被外部访问
支持嵌套的隔离机制，即可以在模块中嵌套子模块
细粒度的访问权限控制，尤其是能提供模块内部/模块外部/子模块不同的访问权限则更好
和操作系统的文件访问系统保持一致的视图，比如期望子文件夹可以对应子模块是一个非常符合直觉的方法
支持类似命名空间的隔离和访问，比如支持重新导出一些模块中公开的可访问部分到另外一个空间中或者嵌套的命名、重命名模块等
和构建系统、打包系统具有清晰易懂的交互接口；支持语言本身和IDE、语法检查等生态系统工具设施的无缝融合
要同时实现这些目标，并没有想象中的容易；其它一些流行的编程语言其实都小心仔细地对这些可能“讨好”程序员的目标做取舍，并在定义中详细地描述好限制。 比如Java一开始用Jar打包的方式来模拟模块，但是却由于不支持嵌套子模块中复杂的访问控制而遭到很多用户的不满；而Go语言中的模块和文件系统中文件名的纠葛同样也是Go语言中一个晦涩的知识点。 NodeJS通过NPM机制来提供模块化支持，然而其嵌套的打包方式和让人窒息的依赖树结构导致打包的时候需要依赖其它的第三方工具才能避免中招。

后向兼容的艰难挑战
C++的模块机制是奔着替换旧有的头文件包含机制的目标来的，同时又因为需要照顾庞大的既有代码库不被破坏而不得不同时兼容头文件包含机制。 和已有的其它语言特性一样，这种向后兼容带来的额外复杂性是否是必要的还又不小不同的声音，不过主流的声音还是决定走兼容的道路。

基本语法
如果我们希望声明一个模块，可以用如下的语法

export module example; //声明一个模块名字为example
export int add(int first, int second) { //可以导出的函数
    return first + second;
}
因为我们丢弃了头文件的方法，可以将该模块定义保存在example.cppm的文件中。这里的cppm后缀用于告诉编译器这是一个模块定义文件。

假设我们希望使用该模块，则用如下的代码

import example; //导入上述定义的模块
int main() {
    add(1, 2); //调用example模块中的函数
}
分离模块接口和实现

如果我们想分离模块的声明和实现，将他们放在不同的文件中，这样更符合传统的接口定义和实现分离的编写代码方法（其实可以看作是C++比Java更干净的一个地方），我们可以对上面的example.cppm做如下的修改

export module example;
extern int add(int first, int second);
然后创建一个源代码文件，放置模块函数的实现

module example; //当前模块是example
int add(int first, int second) {
    return first + second;
}
出于灵活起见，C++20支持将一个模块中声明的函数放在多个模块实现单元中分别实现，这样更容易实现干净的代码，并提高编译速度。

隔离权限指定

模块访问权是通过export声明来指定的，没有声明的类或者函数等默认是不能被外部代码访问的；基于声明的语法也决定了如果分离声明和实现，可见性在实现单元中其实是忽略的。

为了避免代码变得过于啰嗦，语法层面上也支持通过括号作用于一次性声明多个导出函数或者类，比如

export module example;
export {
    void doSth();
    int doAnother(auto x, auto y);
}
void internalImpl(); //外部不可访问
模块和namespace是正交的语言设施

旧的C++标准早就支持通过namespace来实现信息封装和隔离，而新的module机制可以和namespace结合使用，提供清晰的隔离结构，比如

export module example;
export namespace name {
    void doSth();
    int doAnother(auto x, auto y);
}
语言机制上提供了灵活的手段，但是程序员却要自己做好权衡，保持模块的粒度适中，匹配实际的应用场景。

模块重新导出

实际应用中，复杂的软件项目可能有很多形形色色的模块，它们可能处于不同的抽象单元；和应用代码比较近的上层模块可能需要将某些它自己可见的模块开放给上层代码直接使用，提供重新导出的功能可以极大地提高信息封装的能力，提高模块的内聚度减少不必要的耦合。

一个简单的方法就是将import的部分重新放在export块中，即下面的代码例子

export module mid;
export {
    import low_module1;
    import low_module2;
    void myFunc(auto x);
}
标准库中的模块
标准库中提供的工具函数和类显然应该被模块化，只需要使用import std.xxx即可导入。 现代的WG21委员会的工作方式是有很多并行开发但是还没有进入主干库的”准标准库”，编译器可以选择实现，等到对应的规范成熟的时候，它们才会被正式地移入标准库中。

Visual C++的封装方式如下

std.filesystem提供文件系统的库，相当于<experimental/filesystem>
std.memory 提供智能指针的库，相当于<memory>
std.regex提供对正则表达式库的封装，相当于<regex>
std.threading提供对线程库的支持（已经于C++11中正式支持），相当于<atomic>/<future>/<mutex>/<thread>/<shared_mutex>
std.core包含了其它所有的标准库设施
潜在的争议？
作为一门有着30多年历史的语言，模块化机制的一个设计难点就是保持和古老的include机制（本质上是代码的复制）兼容该如何实现。 好在WG21经过漫长的讨论终于实现了起码在理论上完美的兼容 - 用户可以自由混用两者，只要不产生重复和链接问题即可。 Redit的cpp频道里面有人发起了一个是否提供一种机制让用户强制在某一个模块中清理旧有的include模式的讨论，采用的思路正式类似Rust语言的版本指定的思路。

这个想法其实有很重要的现实意义，因此有很多自身CPP用户发表了自己的看法，大概标准定义成现在这个样子应该主要是两个方面的原因

委员会中的代表有很多来自于大公司，这些公司有海量的遗留代码；因此出于自身利益的考虑他们不会选择一种不兼容的方案和自己过不去。
社区分裂的风险，这个其实从C++03诞生依赖就有人开始质疑，乃至于早期的D语言就是冲着这一点不满才决定选择单干，可惜有评论认为现在的D语言的分裂情况和C++比较起来完全是不遑多让的。
这些问题其实都是很现实的问题，个人觉得WG21选择向后兼容的思路并没有什么问题，因为从新发明轮子的时候都是简单的，真正复杂的是如何长期稳定地维护和更新。 C++的使用领域一直在缩小（或者有人说它是退回到了适合的领域）是个不争的事实，然而在适合的领域，它的优势不光在于语言本身还依赖于这些遗留系统的支撑。